   ## what's new in EBNFParser 0.1.2:
	1.
		separate parser with tokenizer.
		You are allowed to whether to define tokenizer automatically in EBNF files.
		You are allowed to define a funtion to be the tokenizer at the first line in a EBNF file
		for instance:
			using {{ lambda string:list(string) }} # or just list

		And you are allowed to write a tokenizer definition in another file, for instance:

		file: ./xxx.eebnf
			using python.token
		file: ./python/token
			lambda x : string(x)
		Take care that you can just write an expression!!!
	2.
		the meta information format has changed from

			"meta":{"rowIdx":<rowIdx>, "count":<count>, "fileName":<fileName>}
		to
			"meta":[<rowIdx>, <count>, <fileName>]

	Enjoy it:)


   ## what's new in EBNFParser 0.1.2.2:
	
	You're now allowed to define parsers named by chinese characters. 


   ## what's new in EBNFParser 0.1.3.1:
	
	There is a module named `token` which is in CPython STL.
	As a result, I changed the name of a specific file generated by Parser Generator from `token.py` to `etoken.py`.
 
   ## what's new in EBNFParser 0.1.3.4(0.1.4):
	
	Fixed bugs for Windows users.
	Now just use following command 

	```
	parserGenerator <grammarFile> <outputParser.py> 
		-lang <yourLanguageName> 
		-comment <hasComments?>
		-multiline <hasMultilineDefinitions?>
	```
	to generate a parser.

   ## what's new in EBNFParser 0.2.0:
	
	I think that I have just found a fantastic method to solve left recursion problem.
	The way to do it is just:

		- mark the left-recursive parser node and store the tail of each epsilon production of this parser as TAIL.
		```
		a ::= a b c | a '=>' d | c
		# TAIL = b c | '=>' d 
		```
		- when an ast named RESULT has been parsed, just

			* make an new ast also named RESULT', take RESULT as the first elem in RESULT'!!!
			* continue parsing by using TAIL.
	
	I will refactor this method sooner to make my codes more elegant.

	- P.S
		Sometimes I think my ideas might come from God's Revelation.
		It seems so incredible for me to totally solve a part of Principles by myself.
	
	## what's new in EBNFParser 1.0:

		- Totally support any kind of left recursion now.

		- Some optimization on Bootstrap Compiler.
			
			for instance, the result of following one 
				`a ::= b c d | b d e | b d f`
			can be transformed to the same as
				`a ::= b(c d | b d (e|f) )`
		
		- LiteralParser will get a result which `Type` is `str`, previously it got an `Ast`.

			In terms of the following case:

			``` test.txt

				B := 'b'
				A ::= B
			
			```

			Let test the parser.

				- Misakawa(Old version).

					```
					parserGenerator ./test.txt ./testParser.py 
					python testLang.py A "b"
					A[B['b']
					  ]
					```
				
				- Ruikowa

					```
					ruiko ./test.txt ./testParser.py 
					python testLang.py A "b"
					A[
				      "b"
					 ]
					```
		- Support Python3.4+!

	## what's new in EBNFParser 1.0.1:

		- fix a bug in `Throw` syntax.
			
			The following syntax should define an ASTParser which will ignore the characters `'\n' and ','` in parsed results, however it used to ignore "'\\n'" and "','". 
			a Throw ['\n', ','] ::= ... 
		
			Now this problem has been fixed.
		
		
	## what's new in EBNFParser 1.0.3:

		- fix a bug in `Throw` syntax:

			There is a bug that ignoring the specific AST in previous versions could be incorrect. Fixed now.
	
	## what's new in EBNFParser 1.0.4:

		- make `SyntaxError` caught by `handle_error` be a more specific `DSLSyntaxError`.

    ## what's new in EBNFParser 1.0.5:

		- add a new api `MetaInfo.max_fetched` to get max possible parsed words count, for making interactive tools.

		 





			
			



	
	 

	
	
	
	
