
from Misakawa.ObjectRegex.Node import Ref, AstParser, SeqParser, LiteralParser, MetaInfo
import re
namespace     = globals()
recurSearcher = set()
token = re.compile('|'.join(['\]','\\n','\[','\:','\/','\-','\,','\+','\*','\)','\(','\%','if(?!\S)','else(?!\S)','lambda(?!\S)','not(?!\S)','or(?!\S)','and(?!\S)','for(?!\S)','in(?!\S)','\d+|\d*\.\d+','True(?!\S)|False(?!\S)|None(?!\S)','[a-zA-Z_][a-zA-Z0-9]*']))
Test = AstParser([Ref('Lambdef')],[Ref('OrTest'),SeqParser([LiteralParser('if(?!\S)', name = '\'if(?!\S)\''),Ref('OrTest'),LiteralParser('else(?!\S)', name = '\'else(?!\S)\''),Ref('Test')], atmost = 1)], name = 'Test')
Lambdef = AstParser([LiteralParser('lambda(?!\S)', name = '\'lambda(?!\S)\''),Ref('Argdef'),LiteralParser.Eliteral(':', name = '\':\''),Ref('Test')], name = 'Lambdef')
OrTest = AstParser([Ref('AndTest'),SeqParser([Ref('Or'),Ref('AndTest')])], name = 'OrTest')
AndTest = AstParser([Ref('NotTest'),SeqParser([Ref('And'),Ref('NotTest')])], name = 'AndTest')
NotTest = AstParser([Ref('Arith')],[Ref('Not'),Ref('NotTest')], name = 'NotTest')
Arith = AstParser([Ref('Term'),SeqParser([SeqParser([Ref('Add')],[Ref('Sub')], atleast = 1, atmost = 1),Ref('Term')])], name = 'Arith')
Term = AstParser([Ref('Factor'),SeqParser([SeqParser([Ref('Mul')],[Ref('Div')],[Ref('Mod')], atleast = 1, atmost = 1),Ref('Factor')])], name = 'Term')
Factor = AstParser([Ref('Expr')],[SeqParser([Ref('Add')],[Ref('Sub')], atleast = 1, atmost = 1),Ref('Factor')], name = 'Factor')
Not = LiteralParser('not(?!\S)', name = 'Not')
Or = LiteralParser('or(?!\S)', name = 'Or')
And = LiteralParser('and(?!\S)', name = 'And')
Mod = LiteralParser.Eliteral('%', name = 'Mod')
Mul = LiteralParser.Eliteral('*', name = 'Mul')
Div = LiteralParser.Eliteral('/', name = 'Div')
Add = LiteralParser.Eliteral('+', name = 'Add')
Sub = LiteralParser.Eliteral('-', name = 'Sub')
Expr = AstParser([Ref('Test')],[Ref('Number')],[Ref('Const')],[Ref('Name')],[LiteralParser.Eliteral('(', name = '\'(\''),Ref('ListComp'),LiteralParser.Eliteral(')', name = '\')\'')],[LiteralParser.Eliteral('[', name = '\'[\''),Ref('ListComp'),LiteralParser.Eliteral(']', name = '\']\'')], name = 'Expr')
Argdef = AstParser([Ref('Name'),SeqParser([LiteralParser.Eliteral(',', name = '\',\''),Ref('Name')])], name = 'Argdef')
ListComp = AstParser([Ref('Test'),SeqParser([LiteralParser('for(?!\S)', name = '\'for(?!\S)\''),Ref('Argdef'),LiteralParser('in(?!\S)', name = '\'in(?!\S)\''),Ref('Test')], atmost = 1)], name = 'ListComp')
Number = LiteralParser('\d+|\d*\.\d+', name = 'Number')
Const = LiteralParser('True(?!\S)|False(?!\S)|None(?!\S)', name = 'Const')
Name = LiteralParser('[a-zA-Z_][a-zA-Z0-9]*', name = 'Name')
NEWLINE = LiteralParser.Eliteral('\n', name = 'NEWLINE')
Test.compile(namespace, recurSearcher)
Lambdef.compile(namespace, recurSearcher)
OrTest.compile(namespace, recurSearcher)
AndTest.compile(namespace, recurSearcher)
NotTest.compile(namespace, recurSearcher)
Arith.compile(namespace, recurSearcher)
Term.compile(namespace, recurSearcher)
Factor.compile(namespace, recurSearcher)
Expr.compile(namespace, recurSearcher)
Argdef.compile(namespace, recurSearcher)
ListComp.compile(namespace, recurSearcher)
