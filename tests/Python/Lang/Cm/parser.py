
from Misakawa.ObjectRegex.Node import Ref, AstParser, SeqParser, LiteralParser, MetaInfo
import re
namespace     = globals()
recurSearcher = set()
token = re.compile('|'.join(['\}','\{','\`','\]','\[','\=\>','\=','\:','\/\*','\.','\-\>','\,','\*\/','\)','\(','/\*[\W\w]*?/\*','//[^\n]*','[a-z]*"[\w|\W]*"','0[XxOoBb][\da-fA-F]+','\d+(?:\.\d+|)(?:E\-{0,1}\d+|)','null(?!\S)|false(?!\S)|true(?!\S)',';|\n','[a-zA-Z_][a-z0-9A-Z_]*','break(?!\S)|return(?!\S)|continue(?!\S)','if(?!\S)','else(?!\S)','while(?!\S)','struct(?!\S)','let(?!\S)','var(?!\S)','\/\/|\/|\|\||\||\>\>|\<\<|\>\=|\<\=|\<\-|\>|\<|\=\>|\-\-|\+\+|\*\*|\+|\-|\*|\=\=|\=|\%|\^','\?|\!|\&|\$|\@|\+|\-|\~']))
multilineComment = AstParser([LiteralParser.Eliteral('/*', name = '\'/*\''),Ref('multilineComment'),LiteralParser.Eliteral('*/', name = '\'*/\'')],[LiteralParser('/\*[\W\w]*?/\*', name = '\'/\*[\W\w]*?/\*\'')], name = 'multilineComment')
Comment = LiteralParser('//[^\n]*', name = 'Comment')
String = LiteralParser('[a-z]*"[\w|\W]*"', name = 'String')
numberLiteral = LiteralParser('0[XxOoBb][\da-fA-F]+', name = 'numberLiteral')
Decimal = LiteralParser('\d+(?:\.\d+|)(?:E\-{0,1}\d+|)', name = 'Decimal')
Constant = LiteralParser('null(?!\S)|false(?!\S)|true(?!\S)', name = 'Constant')
EOL = LiteralParser(';|\n', name = 'EOL')
Insertable = AstParser([Ref('EOL')],[Ref('Comment')],[Ref('multilineComment')], name = 'Insertable')
simpleName = LiteralParser('[a-zA-Z_][a-z0-9A-Z_]*', name = 'simpleName')
Identity = AstParser([Ref('simpleName')],[LiteralParser.Eliteral('`', name = '\'`\''),Ref('simpleName'),LiteralParser.Eliteral('`', name = '\'`\'')], name = 'Identity')
labelDef = AstParser([LiteralParser.Eliteral(':', name = '\':\''),Ref('Identity')], name = 'labelDef')
block = AstParser([LiteralParser.Eliteral('{', name = '\'{\''),Ref('statements'),LiteralParser.Eliteral('}', name = '\'}\'')], name = 'block')
body = AstParser([Ref('block')],[Ref('statement')],[SeqParser([Ref('Insertable')]),Ref('body'),SeqParser([Ref('Insertable')])], name = 'body')
statement = AstParser([Ref('flowControl')],[Ref('declaration')],[SeqParser([Ref('flowControlSign')], atmost = 1),Ref('expression'),SeqParser([Ref('EOL')], atmost = 1)],[SeqParser([Ref('Insertable')]),Ref('statement'),SeqParser([Ref('Insertable')])], name = 'statement')
flowControlSign = LiteralParser('break(?!\S)|return(?!\S)|continue(?!\S)', name = 'flowControlSign')
flowControl = AstParser([Ref('If')],[Ref('While')], name = 'flowControl')
If = AstParser([LiteralParser('if(?!\S)', name = '\'if(?!\S)\''),LiteralParser.Eliteral('(', name = '\'(\''),Ref('expression'),LiteralParser.Eliteral(')', name = '\')\''),Ref('body'),SeqParser([LiteralParser('else(?!\S)', name = '\'else(?!\S)\''),Ref('body')], atmost = 1)], name = 'If')
While = AstParser([LiteralParser('while(?!\S)', name = '\'while(?!\S)\''),LiteralParser.Eliteral('(', name = '\'(\''),Ref('expression'),LiteralParser.Eliteral(')', name = '\')\''),Ref('body')], name = 'While')
declaration = AstParser([Ref('structDeclaration')],[Ref('variableDeclaration')], name = 'declaration')
structDeclaration = AstParser([LiteralParser('struct(?!\S)', name = '\'struct(?!\S)\''),Ref('Identity'),LiteralParser.Eliteral('{', name = '\'{\''),SeqParser([SeqParser([Ref('Insertable')]),Ref('variableDeclarationEntry'),SeqParser([Ref('Insertable')])]),LiteralParser.Eliteral('}', name = '\'}\'')], name = 'structDeclaration')
variableDeclarationEntry = AstParser([Ref('Identity'),SeqParser([LiteralParser.Eliteral(':', name = '\':\''),Ref('Type')], atmost = 1)], name = 'variableDeclarationEntry')
variableDeclarationEntryList = AstParser([Ref('variableDeclarationEntry'),SeqParser([LiteralParser.Eliteral(',', name = '\',\''),Ref('variableDeclarationEntry')])], name = 'variableDeclarationEntryList')
variableDeclaration = AstParser([SeqParser([LiteralParser('let(?!\S)', name = '\'let(?!\S)\'')],[LiteralParser('var(?!\S)', name = '\'var(?!\S)\'')], atleast = 1, atmost = 1),Ref('variableDeclarationEntry'),SeqParser([LiteralParser.Eliteral('=', name = '\'=\''),Ref('expression')], atmost = 1)], name = 'variableDeclaration')
Type = AstParser([LiteralParser.Eliteral('[', name = '\'[\''),Ref('TypeList'),LiteralParser.Eliteral('=>', name = '\'=>\''),Ref('Type'),LiteralParser.Eliteral(']', name = '\']\'')],[Ref('Identity')], name = 'Type')
TypeList = AstParser([Ref('Type'),SeqParser([LiteralParser.Eliteral(',', name = '\',\''),Ref('Type')])], name = 'TypeList')
BinaryOperator = LiteralParser('\/\/|\/|\|\||\||\>\>|\<\<|\>\=|\<\=|\<\-|\>|\<|\=\>|\-\-|\+\+|\*\*|\+|\-|\*|\=\=|\=|\%|\^', name = 'BinaryOperator')
UnaryOperator = LiteralParser('\?|\!|\&|\$|\@|\+|\-|\~', name = 'UnaryOperator')
expression = AstParser([Ref('LambdaDef')],[Ref('BinaryOperation')], name = 'expression')
LambdaDef = AstParser([Ref('variableDeclarationEntryList'),LiteralParser.Eliteral('->', name = '\'->\''),Ref('body')],[LiteralParser.Eliteral('{', name = '\'{\''),SeqParser([Ref('Insertable')]),SeqParser([Ref('variableDeclarationEntryList'),LiteralParser.Eliteral('->', name = '\'->\'')], atmost = 1),Ref('statements'),LiteralParser.Eliteral('}', name = '\'}\'')], name = 'LambdaDef')
BinaryOperation = AstParser([Ref('UnaryOperation'),SeqParser([Ref('BinaryOperator'),Ref('UnaryOperation')])], name = 'BinaryOperation')
UnaryOperation = AstParser([Ref('AtomExpr')],[Ref('UnaryOperator'),Ref('UnaryOperation')], name = 'UnaryOperation')
AtomExpr = AstParser([Ref('Atom'),SeqParser([Ref('Trailer')])], name = 'AtomExpr')
expressionList = AstParser([Ref('expression'),SeqParser([LiteralParser.Eliteral(',', name = '\',\''),Ref('expression')])], name = 'expressionList')
Trailer = AstParser([LiteralParser.Eliteral('(', name = '\'(\''),Ref('expressionList'),LiteralParser.Eliteral(')', name = '\')\''),SeqParser([Ref('LambdaDef')], atmost = 1)],[LiteralParser.Eliteral('.', name = '\'.\''),Ref('Identity')], name = 'Trailer')
Atom = AstParser([Ref('Constant')],[Ref('String')],[Ref('Identity')],[Ref('numberLiteral')],[Ref('Decimal')],[LiteralParser.Eliteral('(', name = '\'(\''),Ref('expression'),LiteralParser.Eliteral(')', name = '\')\'')], name = 'Atom')
statements = AstParser([SeqParser([SeqParser([Ref('Insertable')]),SeqParser([Ref('statement')]),SeqParser([Ref('Insertable')])])], name = 'statements')
multilineComment.compile(namespace, recurSearcher)
Insertable.compile(namespace, recurSearcher)
Identity.compile(namespace, recurSearcher)
labelDef.compile(namespace, recurSearcher)
block.compile(namespace, recurSearcher)
body.compile(namespace, recurSearcher)
statement.compile(namespace, recurSearcher)
flowControl.compile(namespace, recurSearcher)
If.compile(namespace, recurSearcher)
While.compile(namespace, recurSearcher)
declaration.compile(namespace, recurSearcher)
structDeclaration.compile(namespace, recurSearcher)
variableDeclarationEntry.compile(namespace, recurSearcher)
variableDeclarationEntryList.compile(namespace, recurSearcher)
variableDeclaration.compile(namespace, recurSearcher)
Type.compile(namespace, recurSearcher)
TypeList.compile(namespace, recurSearcher)
expression.compile(namespace, recurSearcher)
LambdaDef.compile(namespace, recurSearcher)
BinaryOperation.compile(namespace, recurSearcher)
UnaryOperation.compile(namespace, recurSearcher)
AtomExpr.compile(namespace, recurSearcher)
expressionList.compile(namespace, recurSearcher)
Trailer.compile(namespace, recurSearcher)
Atom.compile(namespace, recurSearcher)
statements.compile(namespace, recurSearcher)
