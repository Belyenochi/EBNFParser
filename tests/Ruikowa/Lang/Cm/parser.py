
from Ruikowa.ObjectRegex.Node import Ref, AstParser, SeqParser, LiteralParser, CharParser, MetaInfo
from etoken import token 
import re
namespace     = globals()
recurSearcher = set()
Any = LiteralParser('^((?!/\*|\*/|\n)[\s\S])*$', name = 'Any')
multilineComment = AstParser([LiteralParser('/*', name='\'/*\''),SeqParser([SeqParser([Ref('Any')],[Ref('NEWLINE')],[Ref('multilineComment')], atleast = 1, atmost = 1)]),LiteralParser('*/', name='\'*/\'')], name = 'multilineComment')
Comment = LiteralParser('//[^\n]*', name = 'Comment', isRegex = True)
String = LiteralParser('[a-z]*"[\w|\W]*"', name = 'String', isRegex = True)
numberLiteral = LiteralParser('0[XxOoBb][\da-fA-F]+', name = 'numberLiteral', isRegex = True)
Decimal = LiteralParser('\d+(?:\.\d+|)(?:E\-{0,1}\d+|)', name = 'Decimal', isRegex = True)
Constant = LiteralParser('null|false|true', name = 'Constant')
NEWLINE = LiteralParser('\n', name = 'NEWLINE', isRegex = True)
EOL = LiteralParser(';', name = 'EOL', isRegex = True)
I = AstParser([Ref('NEWLINE')],[Ref('Comment')],[Ref('multilineComment')], name = 'I')
simpleName = LiteralParser('[a-zA-Z_][a-z0-9A-Z_]*', name = 'simpleName', isRegex = True)
Identifier = AstParser([Ref('simpleName')],[LiteralParser('`', name='\'`\''),Ref('simpleName'),LiteralParser('`', name='\'`\'')], name = 'Identifier')
labelDeclaration = AstParser([LiteralParser(':', name='\':\''),Ref('Identifier')], name = 'labelDeclaration')
block = AstParser([LiteralParser('{', name='\'{\''),SeqParser([Ref('variableDeclarationEntryList'),SeqParser([LiteralParser(':', name='\':\''),Ref('Type')],[LiteralParser('=>', name='\'=>\''),Ref('Type')], atmost = 1),LiteralParser('->', name='\'->\'')], atmost = 1),Ref('statements'),LiteralParser('}', name='\'}\'')], name = 'block')
body = AstParser([Ref('block')],[Ref('statement')], name = 'body')
module = AstParser([Ref('simpleName'),SeqParser([LiteralParser(',', name='\',\''),Ref('simpleName')])], name = 'module')
moduleDeclaration = AstParser([LiteralParser('module', name='\'module\''),Ref('module')], name = 'moduleDeclaration')
Import = AstParser([LiteralParser('import', name='\'import\''),Ref('module')], name = 'Import')
statement = AstParser([SeqParser([Ref('flowControl')],[Ref('declaration')],[Ref('flowControlSign'),SeqParser([Ref('Identifier')], atmost = 1)],[Ref('expression')], atleast = 1, atmost = 1),SeqParser([Ref('EOL')], atmost = 1)], name = 'statement')
flowControlSign = LiteralParser('break|return|continue', name = 'flowControlSign')
flowControl = AstParser([Ref('If')],[Ref('While')], name = 'flowControl')
If = AstParser([LiteralParser('if', name='\'if\''),LiteralParser('(', name='\'(\''),Ref('expression'),LiteralParser(')', name='\')\''),Ref('body'),SeqParser([LiteralParser('else', name='\'else\''),Ref('body')], atmost = 1)], name = 'If')
While = AstParser([SeqParser([Ref('labelDeclaration')], atmost = 1),LiteralParser('while', name='\'while\''),LiteralParser('(', name='\'(\''),Ref('expression'),LiteralParser(')', name='\')\''),Ref('body')], name = 'While')
declaration = AstParser([Ref('structDeclaration')],[Ref('moduleDeclaration')],[Ref('Import')],[Ref('variableDeclaration')], name = 'declaration')
structDeclaration = AstParser([LiteralParser('struct', name='\'struct\''),Ref('Identifier'),LiteralParser('{', name='\'{\''),SeqParser([SeqParser([Ref('I')]),Ref('variableDeclarationEntry'),SeqParser([LiteralParser(',', name='\',\'')], atmost = 1),SeqParser([Ref('I')])]),LiteralParser('}', name='\'}\'')], name = 'structDeclaration')
variableDeclarationEntry = AstParser([Ref('Identifier'),SeqParser([LiteralParser(':', name='\':\''),Ref('Type')], atmost = 1)], name = 'variableDeclarationEntry')
variableDeclarationEntryList = AstParser([SeqParser([Ref('I')]),Ref('variableDeclarationEntry'),SeqParser([SeqParser([Ref('I')]),LiteralParser(',', name='\',\''),SeqParser([Ref('I')]),Ref('variableDeclarationEntry')]),SeqParser([Ref('I')])], name = 'variableDeclarationEntryList')
variableDeclaration = AstParser([SeqParser([LiteralParser('let', name='\'let\'')],[LiteralParser('var', name='\'var\'')], atleast = 1, atmost = 1),Ref('variableDeclarationEntry'),SeqParser([LiteralParser('=', name='\'=\''),SeqParser([Ref('I')]),Ref('expression')], atmost = 1)], name = 'variableDeclaration')
Type = AstParser([LiteralParser('[', name='\'[\''),SeqParser([Ref('TypeList')], atmost = 1),LiteralParser('=>', name='\'=>\''),Ref('Type'),LiteralParser(']', name='\']\'')],[Ref('Identifier')], name = 'Type')
TypeList = AstParser([Ref('Type'),SeqParser([LiteralParser(',', name='\',\''),Ref('Type')])], name = 'TypeList')
genericParameters = AstParser([LiteralParser('<', name='\'<\''),Ref('Identifier'),SeqParser([LiteralParser(',', name='\',\''),Ref('Identifier')]),LiteralParser('>', name='\'>\'')], name = 'genericParameters')
BinaryOperator = LiteralParser('\/\/|\/|\|\||\||\>\>|\<\<|\>\=|\<\=|\<\-|\>|\<|\=\>|\-\-|\+\+|\*\*|\+|\-|\*|\=\=|\=|\%|\^', name = 'BinaryOperator', isRegex = True)
UnaryOperator = LiteralParser('\?|\!|\&|\$|\@|\+|\-|\~', name = 'UnaryOperator', isRegex = True)
expression = AstParser([Ref('LambdaDef')],[Ref('BinaryOperation')], name = 'expression')
LambdaDef = AstParser([Ref('variableDeclarationEntry'),LiteralParser('->', name='\'->\''),Ref('body')],[LiteralParser('(', name='\'(\''),Ref('variableDeclarationEntryList'),LiteralParser(')', name='\')\''),SeqParser([LiteralParser(':', name='\':\''),Ref('Type')],[LiteralParser('=>', name='\'=>\''),Ref('Type')], atmost = 1),LiteralParser('->', name='\'->\''),Ref('body')],[Ref('block'),SeqParser([LiteralParser(':', name='\':\''),Ref('Type')], atmost = 1)],[SeqParser([Ref('genericParameters')], atmost = 1),Ref('LambdaDef')], name = 'LambdaDef')
BinaryOperation = AstParser([Ref('UnaryOperation'),SeqParser([Ref('BinaryOperator'),Ref('UnaryOperation')])], name = 'BinaryOperation')
UnaryOperation = AstParser([Ref('AtomExpr')],[Ref('UnaryOperator'),Ref('UnaryOperation')], name = 'UnaryOperation')
AtomExpr = AstParser([Ref('Atom'),SeqParser([Ref('Trailer')])], name = 'AtomExpr')
expressionList = AstParser([SeqParser([Ref('I')]),Ref('expression'),SeqParser([SeqParser([Ref('I')]),LiteralParser(',', name='\',\''),SeqParser([Ref('I')]),Ref('expression')]),SeqParser([Ref('I')])], name = 'expressionList')
Trailer = AstParser([Ref('Call')],[Ref('Access')], name = 'Trailer')
Call = AstParser([LiteralParser('(', name='\'(\''),SeqParser([Ref('expressionList')], atmost = 1),LiteralParser(')', name='\')\''),SeqParser([Ref('LambdaDef')], atmost = 1)], name = 'Call')
Access = AstParser([SeqParser([Ref('I')]),LiteralParser('.', name='\'.\''),Ref('Identifier')], name = 'Access')
Atom = AstParser([Ref('Constant')],[Ref('String')],[Ref('Identifier')],[Ref('numberLiteral')],[Ref('Decimal')],[LiteralParser('(', name='\'(\''),Ref('expression'),LiteralParser(')', name='\')\'')], name = 'Atom')
statements = AstParser([SeqParser([SeqParser([Ref('I')]),SeqParser([Ref('statement')]),SeqParser([Ref('I')])])], name = 'statements')
multilineComment.compile(namespace, recurSearcher)
I.compile(namespace, recurSearcher)
Identifier.compile(namespace, recurSearcher)
labelDeclaration.compile(namespace, recurSearcher)
block.compile(namespace, recurSearcher)
body.compile(namespace, recurSearcher)
module.compile(namespace, recurSearcher)
moduleDeclaration.compile(namespace, recurSearcher)
Import.compile(namespace, recurSearcher)
statement.compile(namespace, recurSearcher)
flowControl.compile(namespace, recurSearcher)
If.compile(namespace, recurSearcher)
While.compile(namespace, recurSearcher)
declaration.compile(namespace, recurSearcher)
structDeclaration.compile(namespace, recurSearcher)
variableDeclarationEntry.compile(namespace, recurSearcher)
variableDeclarationEntryList.compile(namespace, recurSearcher)
variableDeclaration.compile(namespace, recurSearcher)
Type.compile(namespace, recurSearcher)
TypeList.compile(namespace, recurSearcher)
genericParameters.compile(namespace, recurSearcher)
expression.compile(namespace, recurSearcher)
LambdaDef.compile(namespace, recurSearcher)
BinaryOperation.compile(namespace, recurSearcher)
UnaryOperation.compile(namespace, recurSearcher)
AtomExpr.compile(namespace, recurSearcher)
expressionList.compile(namespace, recurSearcher)
Trailer.compile(namespace, recurSearcher)
Call.compile(namespace, recurSearcher)
Access.compile(namespace, recurSearcher)
Atom.compile(namespace, recurSearcher)
statements.compile(namespace, recurSearcher)
